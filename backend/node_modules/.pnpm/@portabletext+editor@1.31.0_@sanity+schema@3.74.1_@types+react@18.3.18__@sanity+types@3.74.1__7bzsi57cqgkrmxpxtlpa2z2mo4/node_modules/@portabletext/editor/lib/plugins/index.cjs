"use strict";
Object.defineProperty(exports, "__esModule", { value: !0 });
var reactCompilerRuntime = require("react-compiler-runtime"), React = require("react"), plugin_eventListener = require("../_chunks-cjs/plugin.event-listener.cjs"), behavior_markdown = require("../_chunks-cjs/behavior.markdown.cjs"), jsxRuntime = require("react/jsx-runtime"), selector_isAtTheStartOfBlock = require("../_chunks-cjs/selector.is-at-the-start-of-block.cjs"), util_reverseSelection = require("../_chunks-cjs/util.reverse-selection.cjs"), utils_index = require("../utils/index.cjs"), behavior_core = require("../_chunks-cjs/behavior.core.cjs");
function _interopDefaultCompat(e) {
  return e && typeof e == "object" && "default" in e ? e : { default: e };
}
var React__default = /* @__PURE__ */ _interopDefaultCompat(React);
function BehaviorPlugin(props) {
  const $ = reactCompilerRuntime.c(4), editor = plugin_eventListener.useEditor();
  let t0, t1;
  return $[0] !== editor || $[1] !== props.behaviors ? (t0 = () => {
    const unregisterBehaviors = props.behaviors.map((behavior) => editor.registerBehavior({
      behavior
    }));
    return () => {
      unregisterBehaviors.forEach(_temp);
    };
  }, t1 = [editor, props.behaviors], $[0] = editor, $[1] = props.behaviors, $[2] = t0, $[3] = t1) : (t0 = $[2], t1 = $[3]), React.useEffect(t0, t1), null;
}
function _temp(unregister) {
  return unregister();
}
const EditorRefPlugin = React__default.default.forwardRef((_, ref) => {
  const $ = reactCompilerRuntime.c(2), editor = plugin_eventListener.useEditor(), portableTextEditorRef = React__default.default.useRef(editor);
  let t0, t1;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = () => portableTextEditorRef.current, t1 = [], $[0] = t0, $[1] = t1) : (t0 = $[0], t1 = $[1]), React__default.default.useImperativeHandle(ref, t0, t1), null;
});
EditorRefPlugin.displayName = "EditorRefPlugin";
function MarkdownPlugin(props) {
  const editor = plugin_eventListener.useEditor();
  return React.useEffect(() => {
    const unregisterBehaviors = behavior_markdown.createMarkdownBehaviors(props.config).map((behavior) => editor.registerBehavior({
      behavior
    }));
    return () => {
      for (const unregisterBehavior of unregisterBehaviors)
        unregisterBehavior();
    };
  }, [editor, props.config]), null;
}
const oneLineBehaviors = [
  /**
   * Hitting Enter on an expanded selection should just delete that selection
   * without causing a line break.
   */
  behavior_core.defineBehavior({
    on: "insert.break",
    guard: ({
      context
    }) => context.selection && selector_isAtTheStartOfBlock.isSelectionExpanded({
      context
    }) ? {
      selection: context.selection
    } : !1,
    actions: [(_, {
      selection
    }) => [{
      type: "delete",
      selection
    }]]
  }),
  /**
   * All other cases of `insert.break` should be aborted.
   */
  behavior_core.defineBehavior({
    on: "insert.break",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * `insert.block` `before` or `after` is not allowed in a one-line editor.
   */
  behavior_core.defineBehavior({
    on: "insert.block",
    guard: ({
      event
    }) => event.placement === "before" || event.placement === "after",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * Other cases of `insert.block` are allowed.
   *
   * If a text block is inserted and the focus block is fully selected, then
   * the focus block can be replaced with the inserted block.
   */
  behavior_core.defineBehavior({
    on: "insert.block",
    guard: ({
      context,
      event
    }) => {
      const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock({
        context
      }), selectionStartPoint = selector_isAtTheStartOfBlock.getSelectionStartPoint({
        context
      }), selectionEndPoint = selector_isAtTheStartOfBlock.getSelectionEndPoint({
        context
      });
      if (!focusTextBlock || !utils_index.isTextBlock(context, event.block) || !selectionStartPoint || !selectionEndPoint)
        return !1;
      const blockStartPoint = util_reverseSelection.getBlockStartPoint(focusTextBlock), blockEndPoint = util_reverseSelection.getBlockEndPoint(focusTextBlock), newFocus = util_reverseSelection.getBlockEndPoint({
        node: event.block,
        path: [{
          _key: event.block._key
        }]
      });
      return util_reverseSelection.isEqualSelectionPoints(blockStartPoint, selectionStartPoint) && util_reverseSelection.isEqualSelectionPoints(blockEndPoint, selectionEndPoint) ? {
        focusTextBlock,
        newFocus
      } : !1;
    },
    actions: [({
      event
    }, {
      focusTextBlock,
      newFocus
    }) => [{
      type: "delete.block",
      blockPath: focusTextBlock.path
    }, {
      type: "insert.block",
      block: event.block,
      placement: "auto"
    }, {
      type: "select",
      selection: {
        anchor: newFocus,
        focus: newFocus
      }
    }]]
  }),
  /**
   * An ordinary `insert.block` is acceptable if it's a text block. In that
   * case it will get merged into the existing text block.
   */
  behavior_core.defineBehavior({
    on: "insert.block",
    guard: ({
      context,
      event
    }) => {
      const focusTextBlock = selector_isAtTheStartOfBlock.getFocusTextBlock({
        context
      }), selectionStartPoint = selector_isAtTheStartOfBlock.getSelectionStartPoint({
        context
      }), selectionEndPoint = selector_isAtTheStartOfBlock.getSelectionEndPoint({
        context
      });
      if (!focusTextBlock || !utils_index.isTextBlock(context, event.block) || !selectionStartPoint || !selectionEndPoint)
        return !1;
      const blockBeforeStartPoint = utils_index.splitTextBlock({
        context,
        block: focusTextBlock.node,
        point: selectionStartPoint
      })?.before, blockAfterEndPoint = utils_index.splitTextBlock({
        context,
        block: focusTextBlock.node,
        point: selectionEndPoint
      })?.after;
      if (!blockBeforeStartPoint || !blockAfterEndPoint)
        return !1;
      const targetBlock = utils_index.mergeTextBlocks({
        context,
        targetBlock: blockBeforeStartPoint,
        incomingBlock: event.block
      }), newFocus = util_reverseSelection.getBlockEndPoint({
        node: targetBlock,
        path: [{
          _key: targetBlock._key
        }]
      }), mergedBlock = utils_index.mergeTextBlocks({
        context,
        targetBlock,
        incomingBlock: blockAfterEndPoint
      });
      return {
        focusTextBlock,
        mergedBlock,
        newFocus
      };
    },
    actions: [(_, {
      focusTextBlock,
      mergedBlock,
      newFocus
    }) => [{
      type: "delete.block",
      blockPath: focusTextBlock.path
    }, {
      type: "insert.block",
      block: mergedBlock,
      placement: "auto"
    }, {
      type: "select",
      selection: {
        anchor: newFocus,
        focus: newFocus
      }
    }]]
  }),
  /**
   * Fallback Behavior to avoid `insert.block` in case the Behaviors above all
   * end up with a falsy guard.
   */
  behavior_core.defineBehavior({
    on: "insert.block",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * If multiple blocks are inserted, then the non-text blocks are filtered out
   * and the text blocks are merged into one block
   */
  behavior_core.defineBehavior({
    on: "insert.blocks",
    guard: ({
      context,
      event
    }) => event.blocks.filter((block) => utils_index.isTextBlock(context, block)).reduce((targetBlock, incomingBlock) => utils_index.mergeTextBlocks({
      context,
      targetBlock,
      incomingBlock
    })),
    actions: [
      // `insert.block` is raised so the Behavior above can handle the
      // insertion
      (_, block) => [behavior_core.raise({
        type: "insert.block",
        block,
        placement: "auto"
      })]
    ]
  }),
  /**
   * Block objects do not fit in a one-line editor
   */
  behavior_core.defineBehavior({
    on: "insert.block object",
    actions: [() => [{
      type: "noop"
    }]]
  }),
  /**
   * `insert.text block` is raised as an `insert.block` so it can be handled
   * by the Behaviors above.
   */
  behavior_core.defineBehavior({
    on: "insert.text block",
    actions: [({
      context,
      event
    }) => [behavior_core.raise({
      type: "insert.block",
      block: {
        _key: context.keyGenerator(),
        _type: context.schema.block.name,
        children: event.textBlock?.children ?? []
      },
      placement: event.placement
    })]]
  })
];
function OneLinePlugin() {
  const $ = reactCompilerRuntime.c(1);
  let t0;
  return $[0] === Symbol.for("react.memo_cache_sentinel") ? (t0 = /* @__PURE__ */ jsxRuntime.jsx(BehaviorPlugin, { behaviors: oneLineBehaviors }), $[0] = t0) : t0 = $[0], t0;
}
exports.EventListenerPlugin = plugin_eventListener.EventListenerPlugin;
exports.BehaviorPlugin = BehaviorPlugin;
exports.EditorRefPlugin = EditorRefPlugin;
exports.MarkdownPlugin = MarkdownPlugin;
exports.OneLinePlugin = OneLinePlugin;
//# sourceMappingURL=index.cjs.map
