{"version":3,"file":"util.reverse-selection.js","sources":["../../src/utils/util.is-keyed-segment.ts","../../src/utils/util.block-offset.ts","../../src/utils/util.get-block-end-point.ts","../../src/utils/util.get-block-start-point.ts","../../src/utils/util.is-equal-selection-points.ts","../../src/utils/util.is-span.ts","../../src/utils/util.reverse-selection.ts"],"sourcesContent":["import type {KeyedSegment, PathSegment} from '@sanity/types'\n\n/**\n * @public\n */\nexport function isKeyedSegment(segment: PathSegment): segment is KeyedSegment {\n  return typeof segment === 'object' && segment !== null && '_key' in segment\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {BlockOffset} from '../behaviors/behavior.types'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {isKeyedSegment} from './util.is-keyed-segment'\n\n/**\n * @public\n */\nexport function blockOffsetToSpanSelectionPoint({\n  value,\n  blockOffset,\n}: {\n  value: Array<PortableTextBlock>\n  blockOffset: BlockOffset\n}) {\n  let offsetLeft = blockOffset.offset\n  let selectionPoint:\n    | {path: [KeyedSegment, 'children', KeyedSegment]; offset: number}\n    | undefined\n\n  for (const block of value) {\n    if (block._key !== blockOffset.path[0]._key) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (offsetLeft === 0) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: 0,\n        }\n        break\n      }\n\n      if (offsetLeft <= child.text.length) {\n        selectionPoint = {\n          path: [...blockOffset.path, 'children', {_key: child._key}],\n          offset: offsetLeft,\n        }\n        break\n      }\n\n      offsetLeft -= child.text.length\n    }\n  }\n\n  return selectionPoint\n}\n\n/**\n * @public\n */\nexport function spanSelectionPointToBlockOffset({\n  value,\n  selectionPoint,\n}: {\n  value: Array<PortableTextBlock>\n  selectionPoint: EditorSelectionPoint\n}): BlockOffset | undefined {\n  let offset = 0\n\n  const blockKey = isKeyedSegment(selectionPoint.path[0])\n    ? selectionPoint.path[0]._key\n    : undefined\n  const spanKey = isKeyedSegment(selectionPoint.path[2])\n    ? selectionPoint.path[2]._key\n    : undefined\n\n  if (!blockKey || !spanKey) {\n    return undefined\n  }\n\n  for (const block of value) {\n    if (block._key !== blockKey) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (!isPortableTextSpan(child)) {\n        continue\n      }\n\n      if (child._key === spanKey) {\n        return {\n          path: [{_key: block._key}],\n          offset: offset + selectionPoint.offset,\n        }\n      }\n\n      offset += child.text.length\n    }\n  }\n}\n","import {\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockEndPoint({\n  node,\n  path,\n}: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelectionPoint {\n  if (isPortableTextTextBlock(node)) {\n    const lastChild = node.children[node.children.length - 1]\n\n    if (lastChild) {\n      return {\n        path: [...path, 'children', {_key: lastChild._key}],\n        offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0,\n      }\n    }\n  }\n\n  return {\n    path,\n    offset: 0,\n  }\n}\n","import {\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n} from '@sanity/types'\nimport type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function getBlockStartPoint({\n  node,\n  path,\n}: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelectionPoint {\n  if (isPortableTextTextBlock(node)) {\n    return {\n      path: [...path, 'children', {_key: node.children[0]._key}],\n      offset: 0,\n    }\n  }\n\n  return {\n    path,\n    offset: 0,\n  }\n}\n","import type {EditorSelectionPoint} from '../types/editor'\n\n/**\n * @public\n */\nexport function isEqualSelectionPoints(\n  a: EditorSelectionPoint,\n  b: EditorSelectionPoint,\n) {\n  return (\n    a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path)\n  )\n}\n","import type {PortableTextChild, PortableTextSpan} from '@sanity/types'\nimport type {EditorContext} from '../selectors'\n\n/**\n * @public\n */\nexport function isSpan(\n  context: Pick<EditorContext, 'schema'>,\n  child: PortableTextChild,\n): child is PortableTextSpan {\n  return child._type === context.schema.span.name\n}\n","import type {EditorSelection} from '../types/editor'\n\n/**\n * @public\n */\nexport function reverseSelection(\n  selection: NonNullable<EditorSelection>,\n): NonNullable<EditorSelection> {\n  if (selection.backward) {\n    return {\n      anchor: selection.focus,\n      focus: selection.anchor,\n      backward: false,\n    }\n  }\n\n  return {\n    anchor: selection.focus,\n    focus: selection.anchor,\n    backward: true,\n  }\n}\n"],"names":["isKeyedSegment","segment","blockOffsetToSpanSelectionPoint","value","blockOffset","offsetLeft","offset","selectionPoint","block","_key","path","isPortableTextTextBlock","child","children","isPortableTextSpan","text","length","spanSelectionPointToBlockOffset","blockKey","undefined","spanKey","getBlockEndPoint","node","lastChild","getBlockStartPoint","isEqualSelectionPoints","a","b","JSON","stringify","isSpan","context","_type","schema","span","name","reverseSelection","selection","backward","anchor","focus"],"mappings":"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"}