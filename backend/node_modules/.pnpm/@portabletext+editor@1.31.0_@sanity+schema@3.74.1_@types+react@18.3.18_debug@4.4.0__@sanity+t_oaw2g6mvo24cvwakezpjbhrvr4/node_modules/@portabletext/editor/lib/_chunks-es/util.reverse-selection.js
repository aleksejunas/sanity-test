import { isPortableTextTextBlock, isPortableTextSpan } from "@sanity/types";
function isKeyedSegment(segment) {
  return typeof segment == "object" && segment !== null && "_key" in segment;
}
function blockOffsetToSpanSelectionPoint({
  value,
  blockOffset
}) {
  let offsetLeft = blockOffset.offset, selectionPoint;
  for (const block of value)
    if (block._key === blockOffset.path[0]._key && isPortableTextTextBlock(block)) {
      for (const child of block.children)
        if (isPortableTextSpan(child)) {
          if (offsetLeft === 0) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: 0
            };
            break;
          }
          if (offsetLeft <= child.text.length) {
            selectionPoint = {
              path: [...blockOffset.path, "children", {
                _key: child._key
              }],
              offset: offsetLeft
            };
            break;
          }
          offsetLeft -= child.text.length;
        }
    }
  return selectionPoint;
}
function spanSelectionPointToBlockOffset({
  value,
  selectionPoint
}) {
  let offset = 0;
  const blockKey = isKeyedSegment(selectionPoint.path[0]) ? selectionPoint.path[0]._key : void 0, spanKey = isKeyedSegment(selectionPoint.path[2]) ? selectionPoint.path[2]._key : void 0;
  if (!(!blockKey || !spanKey)) {
    for (const block of value)
      if (block._key === blockKey && isPortableTextTextBlock(block)) {
        for (const child of block.children)
          if (isPortableTextSpan(child)) {
            if (child._key === spanKey)
              return {
                path: [{
                  _key: block._key
                }],
                offset: offset + selectionPoint.offset
              };
            offset += child.text.length;
          }
      }
  }
}
function getBlockEndPoint({
  node,
  path
}) {
  if (isPortableTextTextBlock(node)) {
    const lastChild = node.children[node.children.length - 1];
    if (lastChild)
      return {
        path: [...path, "children", {
          _key: lastChild._key
        }],
        offset: isPortableTextSpan(lastChild) ? lastChild.text.length : 0
      };
  }
  return {
    path,
    offset: 0
  };
}
function getBlockStartPoint({
  node,
  path
}) {
  return isPortableTextTextBlock(node) ? {
    path: [...path, "children", {
      _key: node.children[0]._key
    }],
    offset: 0
  } : {
    path,
    offset: 0
  };
}
function isEqualSelectionPoints(a, b) {
  return a.offset === b.offset && JSON.stringify(a.path) === JSON.stringify(b.path);
}
function isSpan(context, child) {
  return child._type === context.schema.span.name;
}
function reverseSelection(selection) {
  return selection.backward ? {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !1
  } : {
    anchor: selection.focus,
    focus: selection.anchor,
    backward: !0
  };
}
export {
  blockOffsetToSpanSelectionPoint,
  getBlockEndPoint,
  getBlockStartPoint,
  isEqualSelectionPoints,
  isKeyedSegment,
  isSpan,
  reverseSelection,
  spanSelectionPointToBlockOffset
};
//# sourceMappingURL=util.reverse-selection.js.map
