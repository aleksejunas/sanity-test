import { isSpan } from "../_chunks-es/util.reverse-selection.js";
import { blockOffsetToSpanSelectionPoint, getBlockEndPoint, getBlockStartPoint, isEqualSelectionPoints, isKeyedSegment, reverseSelection, spanSelectionPointToBlockOffset } from "../_chunks-es/util.reverse-selection.js";
import { getTextBlockText, isEmptyTextBlock } from "../_chunks-es/util.is-empty-text-block.js";
import { parseBlock } from "../_chunks-es/parse-blocks.js";
import { sliceBlocks } from "../_chunks-es/util.slice-blocks.js";
function isTextBlock(context, block) {
  return block._type === context.schema.block.name;
}
function mergeTextBlocks({
  context,
  targetBlock,
  incomingBlock
}) {
  const parsedIncomingBlock = parseBlock({
    context,
    block: incomingBlock,
    options: {
      refreshKeys: !0
    }
  });
  return !parsedIncomingBlock || !isTextBlock(context, parsedIncomingBlock) ? targetBlock : {
    ...targetBlock,
    children: [...targetBlock.children, ...parsedIncomingBlock.children],
    markDefs: [...targetBlock.markDefs ?? [], ...parsedIncomingBlock.markDefs ?? []]
  };
}
function splitTextBlock({
  context,
  block,
  point
}) {
  const firstChild = block.children.at(0), lastChild = block.children.at(block.children.length - 1);
  if (!firstChild || !lastChild)
    return;
  const before = sliceBlocks({
    blocks: [block],
    selection: {
      anchor: {
        path: [{
          _key: block._key
        }, "children", {
          _key: firstChild._key
        }],
        offset: 0
      },
      focus: point
    }
  }).at(0), after = sliceBlocks({
    blocks: [block],
    selection: {
      anchor: point,
      focus: {
        path: [{
          _key: block._key
        }, "children", {
          _key: lastChild._key
        }],
        offset: isSpan(context, lastChild) ? lastChild.text.length : 0
      }
    }
  }).at(0);
  if (!(!before || !after) && !(!isTextBlock(context, before) || !isTextBlock(context, after)))
    return {
      before,
      after
    };
}
export {
  blockOffsetToSpanSelectionPoint,
  getBlockEndPoint,
  getBlockStartPoint,
  getTextBlockText,
  isEmptyTextBlock,
  isEqualSelectionPoints,
  isKeyedSegment,
  isSpan,
  isTextBlock,
  mergeTextBlocks,
  reverseSelection,
  sliceBlocks,
  spanSelectionPointToBlockOffset,
  splitTextBlock
};
//# sourceMappingURL=index.js.map
