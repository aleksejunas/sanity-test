{"version":3,"file":"selector.is-at-the-start-of-block.cjs","sources":["../../src/behavior-actions/behavior.guards.ts","../../src/selectors/selector.get-selected-spans.ts","../../src/selectors/selectors.ts","../../src/selectors/selector.get-active-list-item.ts","../../src/selectors/selector.get-active-style.ts","../../src/selectors/selector.get-selection-end-point.ts","../../src/selectors/selector.get-selection-start-point.ts","../../src/selectors/selector.get-next-inline-object.ts","../../src/selectors/selector.get-previous-inline-object.ts","../../src/selectors/selector.get-selection-text.ts","../../src/selectors/selector.is-selection-collapsed.ts","../../src/selectors/selector.is-selection-expanded.ts","../../src/selectors/selector.get-caret-word-selection.ts","../../src/selectors/selector.is-active-annotation.ts","../../src/selectors/selector.is-active-decorator.ts","../../src/selectors/selector.is-active-list-item.ts","../../src/selectors/selector.is-active-style.ts","../../src/selectors/selector.is-at-the-end-of-block.ts","../../src/selectors/selector.is-at-the-start-of-block.ts"],"sourcesContent":["import {\n  isPortableTextListBlock,\n  isPortableTextTextBlock,\n  type PortableTextListBlock,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport type {EditorSchema} from '../editor/define-schema'\n\n/**\n * @alpha\n */\nexport type BehaviorGuards = ReturnType<typeof createGuards>\n\nexport function createGuards({schema}: {schema: EditorSchema}) {\n  function isListBlock(block: unknown): block is PortableTextListBlock {\n    return isPortableTextListBlock(block) && block._type === schema.block.name\n  }\n\n  function isTextBlock(block: unknown): block is PortableTextTextBlock {\n    return isPortableTextTextBlock(block) && block._type === schema.block.name\n  }\n\n  return {isListBlock, isTextBlock}\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextSpan,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getSelectedSpans: EditorSelector<\n  Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedSpans: Array<{\n    node: PortableTextSpan\n    path: [KeyedSegment, 'children', KeyedSegment]\n  }> = []\n\n  const startPoint = context.selection.backward\n    ? context.selection.focus\n    : context.selection.anchor\n  const endPoint = context.selection.backward\n    ? context.selection.anchor\n    : context.selection.focus\n\n  const startBlockKey = isKeySegment(startPoint.path[0])\n    ? startPoint.path[0]._key\n    : undefined\n  const endBlockKey = isKeySegment(endPoint.path[0])\n    ? endPoint.path[0]._key\n    : undefined\n\n  if (!startBlockKey || !endBlockKey) {\n    return selectedSpans\n  }\n\n  const startSpanKey = isKeySegment(startPoint.path[2])\n    ? startPoint.path[2]._key\n    : undefined\n  const endSpanKey = isKeySegment(endPoint.path[2])\n    ? endPoint.path[2]._key\n    : undefined\n\n  for (const block of context.value) {\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    if (block._key === startBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (startSpanKey && child._key === startSpanKey) {\n          if (startPoint.offset < child.text.length) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n\n          if (startSpanKey === endSpanKey) {\n            break\n          }\n\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        if (selectedSpans.length > 0) {\n          selectedSpans.push({\n            node: child,\n            path: [{_key: block._key}, 'children', {_key: child._key}],\n          })\n        }\n      }\n\n      if (startBlockKey === endBlockKey) {\n        break\n      }\n\n      continue\n    }\n\n    if (block._key === endBlockKey) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        if (endSpanKey && child._key === endSpanKey) {\n          if (endPoint.offset > 0) {\n            selectedSpans.push({\n              node: child,\n              path: [{_key: block._key}, 'children', {_key: child._key}],\n            })\n          }\n          break\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n\n      break\n    }\n\n    if (selectedSpans.length > 0) {\n      for (const child of block.children) {\n        if (!isPortableTextSpan(child)) {\n          continue\n        }\n\n        selectedSpans.push({\n          node: child,\n          path: [{_key: block._key}, 'children', {_key: child._key}],\n        })\n      }\n    }\n  }\n\n  return selectedSpans\n}\n","import {\n  isKeySegment,\n  isPortableTextSpan,\n  isPortableTextTextBlock,\n  type KeyedSegment,\n  type PortableTextBlock,\n  type PortableTextListBlock,\n  type PortableTextObject,\n  type PortableTextSpan,\n  type PortableTextTextBlock,\n} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const getFocusBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusListBlock: EditorSelector<\n  {node: PortableTextListBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const guards = createGuards(context)\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && guards.isListBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusTextBlock: EditorSelector<\n  {node: PortableTextTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusBlockObject: EditorSelector<\n  {node: PortableTextObject; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const focusBlock = getFocusBlock({context})\n\n  return focusBlock && !isPortableTextTextBlock(focusBlock.node)\n    ? {node: focusBlock.node, path: focusBlock.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusChild: EditorSelector<\n  | {\n      node: PortableTextObject | PortableTextSpan\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusBlock = getFocusTextBlock({context})\n\n  if (!focusBlock) {\n    return undefined\n  }\n\n  const key = context.selection\n    ? isKeySegment(context.selection.focus.path[2])\n      ? context.selection.focus.path[2]._key\n      : undefined\n    : undefined\n\n  const node = key\n    ? focusBlock.node.children.find((span) => span._key === key)\n    : undefined\n\n  return node && key\n    ? {node, path: [...focusBlock.path, 'children', {_key: key}]}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFocusSpan: EditorSelector<\n  | {node: PortableTextSpan; path: [KeyedSegment, 'children', KeyedSegment]}\n  | undefined\n> = ({context}) => {\n  const focusChild = getFocusChild({context})\n\n  return focusChild && isPortableTextSpan(focusChild.node)\n    ? {node: focusChild.node, path: focusChild.path}\n    : undefined\n}\n\n/**\n * @public\n */\nexport const getFirstBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[0]\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getLastBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  const node = context.value[context.value.length - 1]\n    ? context.value[context.value.length - 1]\n    : undefined\n\n  return node ? {node, path: [{_key: node._key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectedBlocks: EditorSelector<\n  Array<{node: PortableTextBlock; path: [KeyedSegment]}>\n> = ({context}) => {\n  if (!context.selection) {\n    return []\n  }\n\n  const selectedBlocks: Array<{node: PortableTextBlock; path: [KeyedSegment]}> =\n    []\n  const startKey = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n  const endKey = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  if (!startKey || !endKey) {\n    return selectedBlocks\n  }\n\n  for (const block of context.value) {\n    if (block._key === startKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n\n      if (startKey === endKey) {\n        break\n      }\n      continue\n    }\n\n    if (block._key === endKey) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n      break\n    }\n\n    if (selectedBlocks.length > 0) {\n      selectedBlocks.push({node: block, path: [{_key: block._key}]})\n    }\n  }\n\n  return selectedBlocks\n}\n\n/**\n * @public\n */\nexport const getSelectionStartBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getSelectionEndBlock: EditorSelector<\n  | {\n      node: PortableTextBlock\n      path: [KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const key = context.selection.backward\n    ? isKeySegment(context.selection.anchor.path[0])\n      ? context.selection.anchor.path[0]._key\n      : undefined\n    : isKeySegment(context.selection.focus.path[0])\n      ? context.selection.focus.path[0]._key\n      : undefined\n\n  const node = key\n    ? context.value.find((block) => block._key === key)\n    : undefined\n\n  return node && key ? {node, path: [{_key: key}]} : undefined\n}\n\n/**\n * @public\n */\nexport const getPreviousBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let previousBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionStartBlock = getSelectionStartBlock({context})\n\n  if (!selectionStartBlock) {\n    return undefined\n  }\n\n  let foundSelectionStartBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionStartBlock.node._key) {\n      foundSelectionStartBlock = true\n      break\n    }\n\n    previousBlock = {node: block, path: [{_key: block._key}]}\n  }\n\n  if (foundSelectionStartBlock && previousBlock) {\n    return previousBlock\n  }\n\n  return undefined\n}\n\n/**\n * @public\n */\nexport const getNextBlock: EditorSelector<\n  {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n> = ({context}) => {\n  let nextBlock: {node: PortableTextBlock; path: [KeyedSegment]} | undefined\n  const selectionEndBlock = getSelectionEndBlock({context})\n\n  if (!selectionEndBlock) {\n    return undefined\n  }\n\n  let foundSelectionEndBlock = false\n\n  for (const block of context.value) {\n    if (block._key === selectionEndBlock.node._key) {\n      foundSelectionEndBlock = true\n      continue\n    }\n\n    if (foundSelectionEndBlock) {\n      nextBlock = {node: block, path: [{_key: block._key}]}\n      break\n    }\n  }\n\n  if (foundSelectionEndBlock && nextBlock) {\n    return nextBlock\n  }\n\n  return undefined\n}\n","import type {PortableTextListBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveListItem: EditorSelector<\n  PortableTextListBlock['listItem'] | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(context)\n  const selectedBlocks = getSelectedBlocks({context}).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstListItem = firstTextBlock.listItem\n\n  if (!firstListItem) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.listItem === firstListItem)) {\n    return firstListItem\n  }\n\n  return undefined\n}\n","import type {PortableTextTextBlock} from '@sanity/types'\nimport {createGuards} from '../behavior-actions/behavior.guards'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveStyle: EditorSelector<PortableTextTextBlock['style']> = ({\n  context,\n}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const guards = createGuards(context)\n  const selectedBlocks = getSelectedBlocks({context}).map((block) => block.node)\n  const selectedTextBlocks = selectedBlocks.filter(guards.isTextBlock)\n\n  const firstTextBlock = selectedTextBlocks.at(0)\n\n  if (!firstTextBlock) {\n    return undefined\n  }\n\n  const firstStyle = firstTextBlock.style\n\n  if (!firstStyle) {\n    return undefined\n  }\n\n  if (selectedTextBlocks.every((block) => block.style === firstStyle)) {\n    return firstStyle\n  }\n\n  return undefined\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectionEndPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  return context.selection.backward\n    ? context.selection.anchor\n    : context.selection.focus\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectionStartPoint: EditorSelector<\n  EditorSelectionPoint | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  return context.selection.backward\n    ? context.selection.focus\n    : context.selection.anchor\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getNextInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionEndPoint = getSelectionEndPoint({context})\n  const selectionEndPointChildKey =\n    selectionEndPoint && isKeySegment(selectionEndPoint.path[2])\n      ? selectionEndPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionEndPointChildKey) {\n    return undefined\n  }\n\n  let endPointChildFound = false\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionEndPointChildKey) {\n      endPointChildFound = true\n      continue\n    }\n\n    if (!isSpan(context, child) && endPointChildFound) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n      break\n    }\n  }\n\n  return inlineObject\n}\n","import {\n  isKeySegment,\n  type KeyedSegment,\n  type PortableTextObject,\n} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isSpan} from '../utils'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n */\nexport const getPreviousInlineObject: EditorSelector<\n  | {\n      node: PortableTextObject\n      path: [KeyedSegment, 'children', KeyedSegment]\n    }\n  | undefined\n> = ({context}) => {\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionStartPoint = getSelectionStartPoint({context})\n  const selectionStartPointChildKey =\n    selectionStartPoint && isKeySegment(selectionStartPoint.path[2])\n      ? selectionStartPoint.path[2]._key\n      : undefined\n\n  if (!focusTextBlock || !selectionStartPointChildKey) {\n    return undefined\n  }\n\n  let inlineObject:\n    | {\n        node: PortableTextObject\n        path: [KeyedSegment, 'children', KeyedSegment]\n      }\n    | undefined\n\n  for (const child of focusTextBlock.node.children) {\n    if (child._key === selectionStartPointChildKey) {\n      break\n    }\n\n    if (!isSpan(context, child)) {\n      inlineObject = {\n        node: child,\n        path: [...focusTextBlock.path, 'children', {_key: child._key}],\n      }\n    }\n  }\n\n  return inlineObject\n}\n","import {isPortableTextSpan, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {isKeyedSegment} from '../utils/util.is-keyed-segment'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport const getSelectionText: EditorSelector<string> = ({context}) => {\n  let text = ''\n\n  const {value, selection} = context\n\n  if (!value || !selection) {\n    return text\n  }\n\n  const forwardSelection = selection.backward\n    ? reverseSelection(selection)\n    : selection\n\n  if (!forwardSelection) {\n    return text\n  }\n\n  for (const block of value) {\n    if (\n      isKeyedSegment(forwardSelection.anchor.path[0]) &&\n      block._key !== forwardSelection.anchor.path[0]._key\n    ) {\n      continue\n    }\n\n    if (!isPortableTextTextBlock(block)) {\n      continue\n    }\n\n    for (const child of block.children) {\n      if (isPortableTextSpan(child)) {\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key &&\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text =\n            text +\n            child.text.slice(\n              forwardSelection.anchor.offset,\n              forwardSelection.focus.offset,\n            )\n\n          break\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.anchor.path[2]) &&\n          child._key === forwardSelection.anchor.path[2]._key\n        ) {\n          text = text + child.text.slice(forwardSelection.anchor.offset)\n          continue\n        }\n\n        if (\n          isKeyedSegment(forwardSelection.focus.path[2]) &&\n          child._key === forwardSelection.focus.path[2]._key\n        ) {\n          text = text + child.text.slice(0, forwardSelection.focus.offset)\n          break\n        }\n\n        if (text.length > 0) {\n          text = text + child.text\n        }\n      }\n    }\n\n    if (\n      isKeyedSegment(forwardSelection.focus.path[0]) &&\n      block._key === forwardSelection.focus.path[0]._key\n    ) {\n      break\n    }\n  }\n\n  return text\n}\n","import type {EditorSelector} from '../editor/editor-selector'\n\n/**\n * @public\n */\nexport const isSelectionCollapsed: EditorSelector<boolean> = ({context}) => {\n  if (!context.selection) {\n    return false\n  }\n\n  return (\n    JSON.stringify(context.selection.anchor.path) ===\n      JSON.stringify(context.selection.focus.path) &&\n    context.selection?.anchor.offset === context.selection?.focus.offset\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport const isSelectionExpanded: EditorSelector<boolean> = ({context}) => {\n  return !isSelectionCollapsed({context})\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelection} from '../types/editor'\nimport {\n  blockOffsetToSpanSelectionPoint,\n  getBlockEndPoint,\n  getBlockStartPoint,\n  spanSelectionPointToBlockOffset,\n  type BlockOffset,\n} from '../utils'\nimport {getNextInlineObject} from './selector.get-next-inline-object'\nimport {getPreviousInlineObject} from './selector.get-previous-inline-object'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {getSelectionText} from './selector.get-selection-text'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusTextBlock} from './selectors'\n\n/**\n * @public\n * Returns the selection of the of the word the caret is placed in.\n * Note: Only returns a word selection if the current selection is collapsed\n */\nexport const getCaretWordSelection: EditorSelector<EditorSelection> = ({\n  context,\n}) => {\n  if (!context.selection) {\n    return null\n  }\n\n  if (!isSelectionCollapsed({context})) {\n    return null\n  }\n\n  const focusTextBlock = getFocusTextBlock({context})\n  const selectionStartPoint = getSelectionStartPoint({context})\n  const selectionStartOffset = selectionStartPoint\n    ? spanSelectionPointToBlockOffset({\n        value: context.value,\n        selectionPoint: selectionStartPoint,\n      })\n    : undefined\n\n  if (!focusTextBlock || !selectionStartPoint || !selectionStartOffset) {\n    return null\n  }\n\n  const previousInlineObject = getPreviousInlineObject({context})\n  const blockStartPoint = getBlockStartPoint(focusTextBlock)\n  const textBefore = getSelectionText({\n    context: {\n      ...context,\n      selection: {\n        anchor: previousInlineObject\n          ? {path: previousInlineObject.path, offset: 0}\n          : blockStartPoint,\n        focus: selectionStartPoint,\n      },\n    },\n  })\n  const textDirectlyBefore = textBefore.split(/\\s+/).at(-1)\n\n  const nextInlineObject = getNextInlineObject({context})\n  const blockEndPoint = getBlockEndPoint(focusTextBlock)\n  const textAfter = getSelectionText({\n    context: {\n      ...context,\n      selection: {\n        anchor: selectionStartPoint,\n        focus: nextInlineObject\n          ? {path: nextInlineObject.path, offset: 0}\n          : blockEndPoint,\n      },\n    },\n  })\n  const textDirectlyAfter = textAfter.split(/\\s+/).at(0)\n\n  const caretWordStartOffset: BlockOffset = textDirectlyBefore\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset - textDirectlyBefore.length,\n      }\n    : selectionStartOffset\n  const caretWordEndOffset: BlockOffset = textDirectlyAfter\n    ? {\n        ...selectionStartOffset,\n        offset: selectionStartOffset.offset + textDirectlyAfter.length,\n      }\n    : selectionStartOffset\n\n  const caretWordStartSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: context.value,\n    blockOffset: caretWordStartOffset,\n  })\n  const caretWordEndSelectionPoint = blockOffsetToSpanSelectionPoint({\n    value: context.value,\n    blockOffset: caretWordEndOffset,\n  })\n\n  if (!caretWordStartSelectionPoint || !caretWordEndSelectionPoint) {\n    return null\n  }\n\n  const caretWordSelection = {\n    anchor: caretWordStartSelectionPoint,\n    focus: caretWordEndSelectionPoint,\n  }\n\n  return isSelectionExpanded({\n    context: {\n      ...context,\n      selection: caretWordSelection,\n    },\n  })\n    ? caretWordSelection\n    : null\n}\n","import {isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\nimport {getFocusSpan, getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport function isActiveAnnotation(\n  annotation: string,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selectedBlocks = getSelectedBlocks(snapshot)\n    const focusSpan = getFocusSpan(snapshot)\n\n    const selectedSpans = isSelectionExpanded(snapshot)\n      ? getSelectedSpans(snapshot)\n      : focusSpan\n        ? [focusSpan]\n        : []\n\n    if (selectedSpans.length === 0) {\n      return false\n    }\n\n    if (\n      selectedSpans.some(\n        (span) => !span.node.marks || span.node.marks?.length === 0,\n      )\n    ) {\n      return false\n    }\n\n    const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n      isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n    )\n\n    return selectedSpans.every((span) => {\n      const spanMarkDefs =\n        span.node.marks?.flatMap((mark) => {\n          const markDef = selectionMarkDefs.find(\n            (markDef) => markDef._key === mark,\n          )\n\n          return markDef ? [markDef._type] : []\n        }) ?? []\n\n      return spanMarkDefs.includes(annotation)\n    })\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {isSelectionExpanded} from './selector.is-selection-expanded'\n\n/**\n * @public\n */\nexport function isActiveDecorator(decorator: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (isSelectionExpanded(snapshot)) {\n      const selectedSpans = getSelectedSpans(snapshot)\n\n      return (\n        selectedSpans.length > 0 &&\n        selectedSpans.every((span) => span.node.marks?.includes(decorator))\n      )\n    }\n\n    return snapshot.context.activeDecorators.includes(decorator)\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveListItem} from './selector.get-active-list-item'\n\n/**\n * @public\n */\nexport function isActiveListItem(listItem: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeListItem = getActiveListItem(snapshot)\n\n    return activeListItem === listItem\n  }\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport {getActiveStyle} from './selector.get-active-style'\n\n/**\n * @public\n */\nexport function isActiveStyle(style: string): EditorSelector<boolean> {\n  return (snapshot) => {\n    const activeStyle = getActiveStyle(snapshot)\n\n    return activeStyle === style\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheEndOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockEndPoint = utils.getBlockEndPoint(block)\n\n    return utils.isEqualSelectionPoints(context.selection.focus, blockEndPoint)\n  }\n}\n","import type {KeyedSegment, PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {isSelectionCollapsed} from './selector.is-selection-collapsed'\n\n/**\n * @public\n */\nexport function isAtTheStartOfBlock(block: {\n  node: PortableTextBlock\n  path: [KeyedSegment]\n}): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!context.selection || !isSelectionCollapsed({context})) {\n      return false\n    }\n\n    const blockStartPoint = utils.getBlockStartPoint(block)\n\n    return utils.isEqualSelectionPoints(\n      context.selection.focus,\n      blockStartPoint,\n    )\n  }\n}\n"],"names":["createGuards","schema","isListBlock","block","isPortableTextListBlock","_type","name","isTextBlock","isPortableTextTextBlock","getSelectedSpans","context","selection","selectedSpans","startPoint","backward","focus","anchor","endPoint","startBlockKey","isKeySegment","path","_key","undefined","endBlockKey","startSpanKey","endSpanKey","value","child","children","isPortableTextSpan","offset","text","length","push","node","getFocusBlock","key","find","getFocusListBlock","guards","focusBlock","getFocusTextBlock","getFocusBlockObject","getFocusChild","span","getFocusSpan","focusChild","getFirstBlock","getLastBlock","getSelectedBlocks","selectedBlocks","startKey","endKey","getSelectionStartBlock","getSelectionEndBlock","getPreviousBlock","previousBlock","selectionStartBlock","foundSelectionStartBlock","getNextBlock","nextBlock","selectionEndBlock","foundSelectionEndBlock","getActiveListItem","selectedTextBlocks","map","filter","firstTextBlock","at","firstListItem","listItem","every","getActiveStyle","firstStyle","style","getSelectionEndPoint","getSelectionStartPoint","getNextInlineObject","focusTextBlock","selectionEndPoint","selectionEndPointChildKey","endPointChildFound","inlineObject","isSpan","getPreviousInlineObject","selectionStartPoint","selectionStartPointChildKey","getSelectionText","forwardSelection","reverseSelection","isKeyedSegment","slice","isSelectionCollapsed","JSON","stringify","isSelectionExpanded","getCaretWordSelection","selectionStartOffset","spanSelectionPointToBlockOffset","selectionPoint","previousInlineObject","blockStartPoint","getBlockStartPoint","textDirectlyBefore","split","nextInlineObject","blockEndPoint","getBlockEndPoint","textDirectlyAfter","caretWordStartOffset","caretWordEndOffset","caretWordStartSelectionPoint","blockOffsetToSpanSelectionPoint","blockOffset","caretWordEndSelectionPoint","caretWordSelection","isActiveAnnotation","annotation","snapshot","focusSpan","some","marks","selectionMarkDefs","flatMap","markDefs","mark","markDef","includes","isActiveDecorator","decorator","activeDecorators","isActiveListItem","isActiveStyle","isAtTheEndOfBlock","utils","isEqualSelectionPoints","isAtTheStartOfBlock"],"mappings":"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"}