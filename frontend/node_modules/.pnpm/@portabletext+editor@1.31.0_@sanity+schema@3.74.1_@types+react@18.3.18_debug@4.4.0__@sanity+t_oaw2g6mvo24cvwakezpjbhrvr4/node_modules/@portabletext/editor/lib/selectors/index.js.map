{"version":3,"file":"index.js","sources":["../../src/selectors/selector.get-active-annotations.ts","../../src/selectors/selector.get-block-offsets.ts","../../src/selectors/selector.get-selected-slice.ts","../../src/selectors/selector.get-selection.ts","../../src/selectors/selector.get-value.ts","../../src/selectors/selector.is-point-after-selection.ts","../../src/selectors/selector.is-point-before-selection.ts","../../src/selectors/selector.is-overlapping-selection.ts"],"sourcesContent":["import {isPortableTextTextBlock, type PortableTextObject} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {getSelectedSpans} from './selector.get-selected-spans'\nimport {getSelectedBlocks} from './selectors'\n\n/**\n * @public\n */\nexport const getActiveAnnotations: EditorSelector<Array<PortableTextObject>> = (\n  snapshot,\n) => {\n  if (!snapshot.context.selection) {\n    return []\n  }\n\n  const selectedBlocks = getSelectedBlocks(snapshot)\n  const selectedSpans = getSelectedSpans(snapshot)\n\n  if (selectedSpans.length === 0) {\n    return []\n  }\n\n  const selectionMarkDefs = selectedBlocks.flatMap((block) =>\n    isPortableTextTextBlock(block.node) ? (block.node.markDefs ?? []) : [],\n  )\n\n  return selectionMarkDefs.filter((markDef) =>\n    selectedSpans.some((span) => span.node.marks?.includes(markDef._key)),\n  )\n}\n","import type {EditorSelector} from '../editor/editor-selector'\nimport * as utils from '../utils'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\n\n/**\n * @public\n */\nexport const getBlockOffsets: EditorSelector<\n  {start: utils.BlockOffset; end: utils.BlockOffset} | undefined\n> = ({context}) => {\n  if (!context.selection) {\n    return undefined\n  }\n\n  const selectionStartPoint = getSelectionStartPoint({context})\n  const selectionEndPoint = getSelectionEndPoint({context})\n\n  if (!selectionStartPoint || !selectionEndPoint) {\n    return undefined\n  }\n\n  const start = utils.spanSelectionPointToBlockOffset({\n    value: context.value,\n    selectionPoint: selectionStartPoint,\n  })\n  const end = utils.spanSelectionPointToBlockOffset({\n    value: context.value,\n    selectionPoint: selectionEndPoint,\n  })\n\n  return start && end ? {start, end} : undefined\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport {sliceBlocks} from '../utils'\n\n/**\n * @public\n */\nexport const getSelectedSlice: EditorSelector<Array<PortableTextBlock>> = ({\n  context,\n}) => {\n  return sliceBlocks({blocks: context.value, selection: context.selection})\n}\n","import type {EditorSelection, EditorSelector} from './_exports'\n\n/**\n * @public\n */\nexport const getSelection: EditorSelector<EditorSelection> = ({context}) => {\n  return context.selection\n}\n","import type {PortableTextBlock} from '@sanity/types'\nimport type {EditorSelector} from './_exports'\n\n/**\n * @public\n */\nexport const getValue: EditorSelector<Array<PortableTextBlock>> = ({\n  context,\n}) => {\n  return context.value\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointAfterSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const endBlockKey = isKeySegment(selection.focus.path[0])\n      ? selection.focus.path[0]._key\n      : undefined\n    const endChildKey = isKeySegment(selection.focus.path[2])\n      ? selection.focus.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !endBlockKey) {\n      return false\n    }\n\n    let after = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === endBlockKey) {\n        if (block._key !== pointBlockKey) {\n          after = true\n          break\n        }\n\n        // Both the point and the selection end in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !endChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === endChildKey) {\n            if (child._key !== pointChildKey) {\n              after = true\n              break\n            }\n\n            // Both the point and the selection end in this child\n\n            after = point.offset > selection.focus.offset\n            break\n          }\n\n          if (child._key === pointChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === pointBlockKey) {\n        break\n      }\n    }\n\n    return after\n  }\n}\n","import {isKeySegment, isPortableTextTextBlock} from '@sanity/types'\nimport type {EditorSelector} from '../editor/editor-selector'\nimport type {EditorSelectionPoint} from '../types/editor'\nimport {reverseSelection} from '../utils/util.reverse-selection'\n\n/**\n * @public\n */\nexport function isPointBeforeSelection(\n  point: EditorSelectionPoint,\n): EditorSelector<boolean> {\n  return (snapshot) => {\n    if (!snapshot.context.selection) {\n      return false\n    }\n\n    const selection = reverseSelection(snapshot.context.selection)\n\n    const pointBlockKey = isKeySegment(point.path[0])\n      ? point.path[0]._key\n      : undefined\n    const pointChildKey = isKeySegment(point.path[2])\n      ? point.path[2]._key\n      : undefined\n\n    const startBlockKey = isKeySegment(selection.anchor.path[0])\n      ? selection.anchor.path[0]._key\n      : undefined\n    const startChildKey = isKeySegment(selection.anchor.path[2])\n      ? selection.anchor.path[2]._key\n      : undefined\n\n    if (!pointBlockKey || !startBlockKey) {\n      return false\n    }\n\n    let before = false\n\n    for (const block of snapshot.context.value) {\n      if (block._key === pointBlockKey) {\n        if (block._key !== startBlockKey) {\n          before = true\n          break\n        }\n\n        // Both the point and the selection start in this block\n\n        if (!isPortableTextTextBlock(block)) {\n          break\n        }\n\n        if (!pointChildKey || !startChildKey) {\n          break\n        }\n\n        for (const child of block.children) {\n          if (child._key === pointChildKey) {\n            if (child._key !== startChildKey) {\n              before = true\n              break\n            }\n\n            // Both the point and the selection start in this child\n\n            before = point.offset < selection.anchor.offset\n            break\n          }\n\n          if (child._key === startChildKey) {\n            break\n          }\n        }\n      }\n\n      if (block._key === startBlockKey) {\n        break\n      }\n    }\n\n    return before\n  }\n}\n","import type {EditorSelection} from '../types/editor'\nimport type {EditorSelector} from './../editor/editor-selector'\nimport {getSelectionEndPoint} from './selector.get-selection-end-point'\nimport {getSelectionStartPoint} from './selector.get-selection-start-point'\nimport {isPointAfterSelection} from './selector.is-point-after-selection'\nimport {isPointBeforeSelection} from './selector.is-point-before-selection'\n\n/**\n * @public\n */\nexport function isOverlappingSelection(\n  selection: EditorSelection,\n): EditorSelector<boolean> {\n  return ({context}) => {\n    if (!selection || !context.selection) {\n      return false\n    }\n\n    const selectionStartPoint = getSelectionStartPoint({\n      context: {\n        ...context,\n        selection,\n      },\n    })\n    const selectionEndPoint = getSelectionEndPoint({\n      context: {\n        ...context,\n        selection,\n      },\n    })\n\n    if (!selectionStartPoint || !selectionEndPoint) {\n      return false\n    }\n\n    if (!isPointAfterSelection(selectionStartPoint)({context})) {\n      return false\n    }\n\n    if (!isPointBeforeSelection(selectionEndPoint)({context})) {\n      return false\n    }\n\n    return true\n  }\n}\n"],"names":["getActiveAnnotations","snapshot","context","selection","selectedBlocks","getSelectedBlocks","selectedSpans","getSelectedSpans","length","flatMap","block","isPortableTextTextBlock","node","markDefs","filter","markDef","some","span","marks","includes","_key","getBlockOffsets","selectionStartPoint","getSelectionStartPoint","selectionEndPoint","getSelectionEndPoint","start","utils","value","selectionPoint","end","undefined","getSelectedSlice","sliceBlocks","blocks","getSelection","getValue","isPointAfterSelection","point","reverseSelection","pointBlockKey","isKeySegment","path","pointChildKey","endBlockKey","focus","endChildKey","after","child","children","offset","isPointBeforeSelection","startBlockKey","anchor","startChildKey","before","isOverlappingSelection"],"mappings":"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"}